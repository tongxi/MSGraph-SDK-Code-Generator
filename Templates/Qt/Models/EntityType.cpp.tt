<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="SharedQt.template.tt"#>
<#
var entity = host.CurrentType.AsOdcmClass();
var collectionProperties = entity.Properties.Where(prop => prop.IsCollection && prop.LongDescriptionContains("enumerable"));

#>
#include "ODModels.h"

#include <QJsonValue>
#include <QJsonArray>
#include <QVariant>

void <#=ClassTypeName(writer, entity)#>::read(const QJsonObject& json) {
    ODObject::read(json);
<#
foreach(var prop in entity.Properties.Where(p => !p.Type.Name.Equals("Stream")))
{
    var varName = "m" + prop.GetToUpperFirstCharName();   
    if (prop.IsComplex() && !prop.IsSystem() && !prop.IsCollection())
    {
#>
    if (json.contains("<#=prop.Name#>")) {
        <#=varName#> = std::make_shared<<#=prop.GetFullType()#>>();
        <#=varName#>->read(json["<#=prop.Name#>"].toObject());
    }
<#
    }
    else if (!prop.IsCollection()) 
    {
        var readFrom = "json[\"" + prop.Name + "\"]";
#>
    if (json.contains("<#=prop.Name#>")) {
        <#=varName#> = std::make_shared<<#=prop.GetFullType()#>>(<#=prop.GetQTJsonParserConverterFunction(readFrom)#>);
    }
<#
    }
    else 
    {
#>
    if (json.contains("<#=prop.Name#>")) {
        <#=varName#> = std::make_shared<<#=prop.GetFullType()#>>();
        for (const auto& value : json["<#=prop.Name#>"].toArray()) {
<#
        if (prop.IsComplex() && !prop.IsSystem()) {
#>
            <#=prop.Type.GetTypeString()#> data;
            data.read(value.toObject());
            <#=varName#>->append(data);
<#
        } 
        else
        {
#>
            <#=varName#>->append(<#=prop.GetQTJsonParserConverterFunction("value")#>);
<#
        }
#>
        }
    }
    if (json.contains("<#=prop.Name#>@odata.nextLink")) {
        if (<#=varName#> == nullptr) {
            <#=varName#> = std::make_shared<<#=prop.GetFullType()#>>();
        }
        <#=varName#>->setNextLink(json["<#=prop.Name#>@odata.nextLink"].toString());
    }
<#
    }
}
#>
}

void <#=ClassTypeName(writer, entity)#>::write(QJsonObject& json) const {
<#
foreach(var prop in entity.Properties.Where(p => !p.Type.Name.Equals("Stream")))
{
    var varName = "m" + prop.GetToUpperFirstCharName();
#>
    if (<#=varName#> != nullptr) {
<#
    if (prop.IsComplex() && !prop.IsSystem() && !prop.IsCollection())
    {
#>
        QJsonObject <#=prop.Name#>Object;
        <#=varName#>->write(<#=prop.Name#>Object);
        json["<#=prop.Name#>"] = <#=prop.Name#>Object;
<#    
    }
    else if (!prop.IsCollection())
    {
#>
        json["<#=prop.Name#>"] = <#=prop.GetQTPointerTypeToJsonConverter(varName)#>;
<#
    } 
    else 
    {
#>
        QJsonArray <#=prop.Name#>Array;
        for(const auto& value : *<#=varName#>) {
<#
        if (prop.IsComplex() && !prop.IsSystem())
        {
#>
            QJsonObject jsonData;
            value.write(jsonData);
            <#=prop.Name#>Array.append(jsonData);
<#
        }
        else 
        {
#>
            <#=prop.Name#>Array.append(<#=prop.GetQTTypeToJsonConverter("value")#>);
<#
        }
#>
        }
        json["<#=prop.Name#>"] = <#=prop.Name#>Array;
<#
    }
#>
    }
<#
}
#>
}